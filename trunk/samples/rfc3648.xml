<?xml version="1.0" encoding="UTF-8"?>
<!--
    This XML document is the output of clean-for-DTD.xslt; a tool that strips
    extensions to RFC2629(bis) from documents for processing with xml2rfc.
-->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<!DOCTYPE rfc
  PUBLIC "" "rfc2629.dtd">
<rfc number="3648" category="std">
  
  <front>
    <title abbrev="WebDAV Ordered Collections Protocol">Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol</title>
    <author initials="J." surname="Whitehead" fullname="Jim Whitehead">
      <organization abbrev="U.C. Santa Cruz">UC Santa Cruz, Dept. of Computer Science</organization>
      <address>
        <postal>
          <street>1156 High Street</street>
          <city>Santa Cruz</city>
          <region>CA</region>
          <code>95064</code>
          <country>US</country>
        </postal>
        <email>ejw@cse.ucsc.edu</email>
      </address>
    </author>
    <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
      <organization abbrev="greenbytes">greenbytes GmbH</organization>
      <address>
        <postal>
          <street>Salzmannstrasse 152</street>
          <city>Muenster</city><region>NW</region><code>48159</code>
          <country>Germany</country>
        </postal>
        <phone>+49 251 2807760</phone>
        <facsimile>+49 251 2807761</facsimile>
       <email>julian.reschke@greenbytes.de</email>
        <uri>http://greenbytes.de/tech/webdav/</uri>
      </address>
    </author>
    
    <date month="December" year="2003"/>
    
		<workgroup>WEBDAV Working Group</workgroup>

    <keyword>WebDAV</keyword>
    <keyword>ordering</keyword>
    <keyword>ordered collections</keyword>
    <keyword>protocol</keyword>
    <keyword>ORDERPATCH method</keyword>
    <keyword>Position header</keyword>
    <keyword>Ordering-Type header</keyword>
    
    <abstract>
      <t>
        This specification extends the Web Distributed Authoring and Versioning (WebDAV) Protocol
        to support the server-side ordering of collection members. Of particular 
        interest are orderings that are not based on property values, and so 
        cannot be achieved using a search protocol's ordering option and cannot 
        be maintained automatically by the server.  Protocol elements are 
        defined to let clients specify the position in the ordering of each 
        collection member, as well as the semantics governing the ordering.        
      </t>
      
    </abstract>
	</front>

	<middle>

<section title="Notational Conventions">
<t>
  Since this document describes a set of extensions to the WebDAV Distributed
  Authoring Protocol <xref target="RFC2518"/>, which is
  itself an extension to the 
  HTTP/1.1 protocol, the augmented BNF used here to describe protocol elements
  is exactly the same as described in Section 2.1 of HTTP <xref target="RFC2616"/>.
  Since this augmented BNF uses the basic production rules provided in Section 2.2
  of HTTP, these rules apply to this document as well.
</t>
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
  document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
<t>
  This document uses XML DTD fragments as a purely notational convention. WebDAV
  request and response bodies can not be validated due to the specific
  extensibility rules defined in section 23 of <xref target="RFC2518"/> and
  due to the fact that all XML elements defined by this specification use the 
  XML namespace name "DAV:". In particular:
  <list style="numbers">
    <t>element names use the "DAV:" namespace,</t>  
    <t>element ordering is irrelevant,</t>  
    <t>extension elements (elements not already defined as valid child
    elements) may be added anywhere, except where explicitly stated otherwise,</t>  
    <t>extension attributes (attributes not already defined as valid for this
    element) may be added anywhere, except where explicitly stated otherwise.</t>  
  </list>
</t>

</section>

<section title="Introduction">
<t>
  This specification builds on the collection infrastructure provided by 
  the WebDAV Distributed Authoring Protocol, adding support for the 
  server-side ordering of collection members. 
</t>
<t>
  There are many scenarios in which it is useful to impose an ordering on a 
  collection at the server, such as expressing a recommended access order, 
  or a revision history order.  The members of a collection might 
  represent the pages of a book, which need to be presented in order if 
  they are to make sense, or an instructor might create a collection of 
  course readings that she wants to be displayed in the order they are 
  to be read.
</t>
<t>
  Orderings may be based on property values, but this is not always the 
  case.  The resources in the collection may not have properties that can 
  be used to support the desired ordering. Orderings based on properties 
  can be obtained using a search protocol's ordering option, but orderings 
  not based on properties cannot.  These orderings generally need to be 
  maintained by a human user.  
</t>
<t>
  The ordering protocol defined here focuses on support for such human-maintained
  orderings.  Its protocol elements allow clients to specify 
  the position of each collection member in the collection's ordering, as 
  well as the semantics governing the order.  The protocol is designed 
  to allow additional support in the future for orderings that are 
  maintained automatically by the server.
</t>
<t>
  The remainder of this document is structured as follows: <xref target="SECTION.TERMINOLOGY"/>
  defines terminology that will be used throughout the specification.  
  <xref target="SECTION.OVERVIEW"/> provides an overview of ordered collections.
  <xref target="SECTION.CREATING"/> describes how to create an ordered
  collection, and <xref target="SECTION.SETTING"/> discusses how to set a
  member's position in the ordering of a collection.
  <xref target="METHOD_ORDERPATCH"/> explains how to change a collection
  ordering. <xref target="SECTION.LISTING"/> discusses listing the members of an
  ordered collection. <xref target="SECTION.VERSIONING"/> discusses the impact
  on version-controlled collections (as defined in <xref target="RFC3253"/>).
  <xref target="SECTION.DISCOVERY"/> describes capability discovery.  
  Sections <xref target="SECTION.SECURITY" format="counter"/> through <xref target="SECTION.IANA" format="counter"/>
  discuss security, internationalization, and IANA considerations. The
  remaining sections provide supporting information.
</t>
</section>


<section title="Terminology" anchor="SECTION.TERMINOLOGY">
<t>
  The terminology used here follows that in <xref target="RFC2518"/> and
  <xref target="RFC3253"/>. Definitions of the terms resource, Uniform Resource
  Identifier (URI), and Uniform Resource Locator (URL) are provided in
  <xref target="RFC2396"/>.  
</t>

<t><iref item="Ordered Collection"/>
  <?rfc needLines="4"?>Ordered Collection
  <list>
    <t>
     A collection for which the results from a PROPFIND request are 
     guaranteed to be in the order specified for that collection.
		</t>
  </list>
</t>
<t><iref item="Unordered Collection"/>
  <?rfc needLines="4"?>Unordered Collection
  <list>
    <t>
     A collection for which the client cannot depend on the 
     repeatability of the ordering of results from a PROPFIND request.
		</t>
  </list>
</t>
<t><iref item="Client-Maintained Ordering"/>
  <?rfc needLines="4"?>Client-Maintained Ordering
  <list>
    <t>
     An ordering of collection members that is maintained on the server 
     based on client requests specifying the position of each 
     collection member in the ordering.
		</t>
  </list>
</t>
<t><iref item="Server-Maintained Ordering"/>
  <?rfc needLines="4"?>Server-Maintained Ordering
  <list>
    <t>
     An ordering of collection members that is maintained automatically 
     by the server, based on a client's choice of ordering semantics.
		</t>
	</list>
</t>
<t><iref item="Ordering Semantics"/>
  <?rfc needLines="4"?>Ordering Semantics
  <list>
    <t>
      In general, ordering semantics are the set of
      structures or meanings applied to the ordering of the member
      of a specific collection. Within this document, "ordering semantics" refers
      specifically to the structure specified in the DAV:ordering-type 
      property. See <xref target="PROPERTY_ordering-type"/> for more
      information on DAV:ordering-type.
		</t>
	</list>
</t>
<t>
  This document uses the terms "precondition",  "postcondition" and "protected property" as defined in
  <xref target="RFC3253"/>. Servers MUST report pre-/postcondition failures
  as described in section 1.6 of this document.
</t>
</section>
		
<section title="Overview of Ordered Collections" anchor="SECTION.OVERVIEW">
<t>
  If a collection is not ordered, the client cannot depend on the repeatability
  of the ordering of results from a PROPFIND request.  By  specifying an
  ordering for a collection, a client requires the server to follow that
  ordering whenever it responds to a PROPFIND request on that collection.
</t>
<t>
  Server-side orderings may be client-maintained or server-maintained.  
  For client-maintained orderings, a client must specify the ordering 
  position of each of the collection's members, either when the member is 
  added to the collection (using the <xref target="SECTION.SETTING">Position header</xref>) or later (using the 
  <xref target="METHOD_ORDERPATCH">ORDERPATCH</xref> method).  For server-maintained orderings, the server 
  automatically positions each of the collection's members according to 
  the ordering semantics.  This specification supports only client-maintained
  orderings, but is designed to allow the future extension with  
  server-maintained orderings.
</t>
<t>
  A collection that supports ordering is not required to be ordered.
</t>
<t>
  If a collection is ordered, each of its internal member URIs MUST appear
  in 
  the ordering exactly once, and the ordering MUST NOT include any URIs that are not internal members
  of the collection. The server is 
  responsible for enforcing these constraints on orderings.  The server 
  MUST remove an internal member URI from the ordering when it is removed 
  from the collection.
  Removing an internal member MUST NOT affect the ordering of the remaining
  internal members.  
  The server MUST add an internal member URI to the 
  ordering when it is added to the collection.
</t>
<t>
  Only one ordering can be attached to any collection. Multiple orderings 
  of the same resources can be achieved by creating multiple collections 
  referencing those resources, and attaching a different ordering to each 
  collection.
</t>
<t>
  An ordering is considered to be part of the state of a collection 
  resource.  Consequently, the ordering is the same no matter which URI is 
  used to access the collection and is protected by locks or access 
  control constraints on the collection.
</t>

<section title="Additional Collection properties">
<t>
  A DAV:allprop PROPFIND request SHOULD NOT return any of the properties defined 
  in this document.
</t>

<section title="DAV:ordering-type (protected)" anchor="PROPERTY_ordering-type">
<iref item="DAV:ordering-type property" primary="true"/>
<iref item="Properties" subitem="DAV:ordering-type" primary="true"/>
<t>
  The DAV:ordering-type property indicates
  whether the collection is ordered and, if so, uniquely identifies
  the semantics of the ordering. 
  It may
  also point to an explanation of
  the semantics in human and/or
  machine-readable form.  At a minimum, this 
  allows human users who add members to the collection to understand where to
  position them in the ordering.  This property cannot be set using PROPPATCH.
  Its value can only be set by including the Ordering-Type header with a MKCOL
  request or by submitting an ORDERPATCH request.
</t>
<t>
  Ordering types are identified by URIs that uniquely identify the semantics
  of the collection's ordering. The following two URIs are predefined:
  
  
  
  <list style="hanging">
    <t hangText="DAV:custom:"><iref item="DAV:custom ordering type"/>
      The value DAV:custom indicates that the collection is ordered, but the
      semantics governing the ordering are not being advertised.
    </t>
    <t hangText="DAV:unordered:"><iref item="DAV:unordered ordering type"/>
      The value DAV:unordered indicates that the collection is not ordered. That
      is, the client cannot depend on the repeatability of the ordering of results
      from a PROPFIND request. 
    </t>
  </list>
  
  
</t>
<t>
  An ordering-aware client interacting with an ordering-unaware server (e.g.,
  one that is implemented only according to <xref target="RFC2518"/>) SHOULD
  assume that the collection is unordered if a collection does not have
  the DAV:ordering-type property.
</t>
<figure><artwork type="application/xml-dtd"><![CDATA[
<!ELEMENT ordering-type (href) >
]]></artwork></figure>
</section>
</section>
</section>

<section title="Creating an Ordered Collection" anchor="SECTION.CREATING">

<section title="Overview" anchor="SECTION.CREATING.OVERVIEW">
<t>
  When a collection is created, the client MAY request that it be ordered 
  and specify the semantics of the ordering by using the new Ordering-Type 
  header (defined below) with a MKCOL request.   
</t>
<t>
  For collections that are ordered, the client SHOULD identify the semantics of
  the ordering with a URI in the Ordering-Type header, although the client MAY
  simply set the header value to DAV:custom to indicate that the collection is
  ordered but the semantics of the ordering are not being advertised. Setting
  the value to a URI that identifies the ordering semantics provides the
  information a human user or software package needs to insert new collection
  members into the ordering intelligently.  Although the URI in the
  Ordering-Type header MAY point to a resource that contains a definition of
  the semantics of the ordering, clients SHOULD NOT access that resource
  to avoid overburdening its server. A value of DAV:unordered in the
  Ordering-Type header indicates that the client wants the collection to be
  unordered.  If the Ordering-Type header is not present, the collection will
  be unordered.
</t>
<t>
  Additional Marshalling:
  <iref item="Ordering-Type header" primary="true"/>
  <iref item="Headers" subitem="Ordering-Type" primary="true"/>
  <list>
<t>
<figure><artwork type="abnf2616"><![CDATA[   Ordering-Type = "Ordering-Type" ":" absoluteURI
   ; absoluteURI: see [RFC2396], section 3
]]></artwork></figure>
</t>
<t>
  The URI "DAV:unordered" indicates that the collection is not ordered, while  
  "DAV:custom" indicates that the collection is to be ordered, but the 
  semantics of the ordering is not being advertised.  Any other URI value
  indicates that the collection is ordered, and identifies the semantics of the
  ordering. 
</t>
  </list>
</t>
<t>
  Additional Preconditions:
  <list>
    <t>
    <iref item="DAV:ordered-collections-supported precondition" primary="true"/>
    <iref item="Condition Names" subitem="DAV:ordered-collections-supported (pre)" primary="true"/>
    (DAV:ordered-collections-supported): 
    the server MUST support ordered collections
    in the part of the URL namespace identified by the request URL.
    </t>
  </list>
</t>

<t>
  Additional Postconditions:
  <list>
    <t>
    <iref item="DAV:ordering-type-set postcondition" primary="true"/>
    <iref item="Condition Names" subitem="DAV:ordering-type-set (post)" primary="true"/>
    (DAV:ordering-type-set): if the Ordering-Type header was present, the request MUST have
    created a new collection resource with the DAV:ordering-type being set
    according to the Ordering-Type request header. The collection MUST be
    ordered unless the ordering type is
    "DAV:unordered".
    </t>
  </list>
</t>


</section>

<section title="Example: Creating an Ordered Collection">
<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
MKCOL /theNorth/ HTTP/1.1
Host: example.org
Ordering-Type: http://example.org/orderings/compass.html
]]></artwork>
</figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 201 Created
]]></artwork>
</figure>
<t>
  In this example, a new
  ordered collection was created.  Its DAV:ordering-type
  property has 
  the URI from the Ordering-Type header as its value
  http://example.org/orderings/compass.html. In this case, the URI identifies
  the semantics governing a client-maintained ordering.  As new members are
  added to the collection, clients or end users can use the semantics to
  determine where to position the new members in the ordering.
</t> 
</section>
</section>

<section title="Setting the Position of a Collection Member" anchor="SECTION.SETTING">

<section title="Overview" anchor="SECTION.SETTING.OVERVIEW">
<t>
  When a new member is added to a collection with a client-maintained ordering
  (for example, with PUT, COPY, or MKCOL), its position in the ordering can be
  set with the new Position header. The Position header allows the client to
  specify that an internal member URI should be first in the collection's
  ordering, last in the collection's ordering, immediately before some other
  internal member URI in the collection's ordering, or immediately after some
  other internal member URI in the collection's ordering.
</t>
<t>
  If the Position request header is not used when adding a member to an 
  ordered collection, then:
  <list style="symbols">
    <t>
      If the request is replacing an existing resource, the server MUST 
      preserve the present ordering.
    </t>
    <t>
      If the request is adding a new internal member URI to the collection, 
      the server MUST append the new member to the end of the ordering.
    </t>
  </list>
</t>
<t><list><t>
  Note to implementers: this specification does not mandate a specific implementation of
  MOVE operations within the same parent collection. Therefore, servers
  may either implement this as a simple rename operation (preserving the
  collection member's position), or as a sequence of "remove" and "add"
  (causing the semantics of "adding a new member" to apply). Future
  revisions of this specification may specify this behaviour more precisely
  based on future implementation experience.
</t></list></t>
<t>
  Additional Marshalling:
  <list>
<t>
<iref item="Position header" primary="true"/>
<iref item="Headers" subitem="Position" primary="true"/>
<figure><artwork type="abnf2616"><![CDATA[   Position = "Position" ":" ("first" | "last" | 
                             (("before" | "after") segment))
]]></artwork></figure>
</t>
<t>
  segment is defined in Section 3.3 of <xref target="RFC2396"/>.
</t>
<t>
  The segment is interpreted relative to the collection to which the new 
  member is being added. 
</t>
<t>
  When the Position header is present, the
  server MUST insert the new member into the ordering at the
  specified location. 
</t>
<t>
  The "first" keyword indicates that
  the new member is placed
  in the beginning 
  position in the collection's ordering, while "last" indicates that
  the new 
  member is placed
  in the final position in the collection's ordering.  The 
  "before" keyword indicates that
  the new member is added to the collection's 
  ordering immediately prior to the position of the member identified in 
  the segment. Likewise, the "after" keyword indicates that the new member is 
  added to the collection's ordering immediately following the position of 
  the member identified in the segment.
</t>
<t>
  If the request is replacing an existing resource
  and the Position 
  header is present, the server MUST remove the internal member URI from 
  its current
  position, and 
  insert it at the newly
  requested position.
</t>
  </list>
</t>
<t>
  Additional Preconditions:
  <list>
    <t>
    <iref item="DAV:collection-must-be-ordered precondition" primary="true"/>
    <iref item="Condition Names" subitem="DAV:collection-must-be-ordered (pre)" primary="true"/>
    (DAV:collection-must-be-ordered): the target collection MUST be ordered.</t>
    <t>
    <iref item="DAV:segment-must-identify-member precondition" primary="true"/>
    <iref item="Condition Names" subitem="DAV:segment-must-identify-member (pre)" primary="true"/>
    (DAV:segment-must-identify-member): the referenced segment MUST identify a resource that
    exists and is different from the affected resource.</t>
  </list>
</t>
<t>
  Additional Postconditions:
  <list>
    <t>
    <iref item="DAV:position-set postcondition" primary="true"/>
    <iref item="Condition Names" subitem="DAV:position-set (post)" primary="true"/>
    (DAV:position-set): 
    if a Position header is
    present, the
    request MUST create
    the new collection member at the specified
    position.</t>
  </list>
</t>

</section> 
  


<section title="Examples: Setting the Position of a Collection Member">
<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
COPY /~user/dav/spec08.html HTTP/1.1
Host: example.org
Destination: http://example.org/~slein/dav/spec08.html
Position: after requirements.html      
]]></artwork>
</figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 201 Created
]]></artwork>
</figure>
<t>
This request resulted in the creation of a new resource at 
example.org/~slein/dav/spec08.html.  The Position header in this 
example caused the server to set its position in the ordering of the 
/~slein/dav/ collection immediately after requirements.html.
</t>
<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
MOVE /i-d/draft-webdav-prot-08.txt HTTP/1.1
Host: example.org
Destination: http://example.org/~user/dav/draft-webdav-prot-08.txt
Position: first
]]></artwork>
</figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 409 Conflict
Content-Type: text/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:error xmlns:D="DAV:">
  <D:collection-must-be-ordered/>
</D:error> 
]]></artwork>
</figure>
<t>
In this case, the server returned a 409 (Conflict) status code because 
the /~user/dav/ collection is an unordered collection.  
Consequently, the server was unable to satisfy the Position header.
</t>
</section>



<section title="Examples: Renaming a member of an ordered collection">
<t>
  The following sequence of requests will rename a collection member while
  preserving its
  position, independently of how the server implements the MOVE
  operation:
  <list style="numbers">
    <t>PROPFIND collection with depth 1, retrieving the DAV:ordering-type property
    (an interactive client has already likely
    done this in order to display the
    collection's content).</t>
    <t>If the DAV:ordering-type property is present and does not
    equal
    "dav:unordered" (thus if the collection is ordered), determine the
    current
    position (such as "first" or "after x") and setup the Position header
    accordingly.</t>
    <t>Perform the MOVE operation, optionally supplying the Position header 
    computed in the previous step.</t>
  </list>
</t>
</section>



</section>

<section title="Changing a Collection Ordering: ORDERPATCH method" anchor="METHOD_ORDERPATCH">
<iref item="ORDERPATCH method" primary="true"/>
<iref item="Methods" subitem="ORDERPATCH" primary="true"/>
<t>
  The ORDERPATCH method is used to change the ordering semantics of a 
  collection,
  to change the order of the collection's members in the 
  ordering, or both.
</t>
<t>
  The server MUST apply the changes in the order they appear in the order 
  XML element. The server MUST either apply all the changes or apply none 
  of them. If any error occurs during processing, all executed changes 
  MUST be undone and a proper error result returned.
</t>

<t>
  If an ORDERPATCH request changes the ordering semantics, but does not 
  completely specify the order of the collection members, the server MUST 
  assign a position in the ordering to each collection member for which a 
  position was not specified. These server-assigned positions MUST follow the last position
  specified by the client.  The result is that all 
  members for which the client specified a position are at the beginning 
  of the ordering, followed by any members for which the server assigned 
  positions. 
  Note that the ordering of the server-assigned positions is
  not defined by this document, therefore servers can use whatever rule
  seems reasonable (for instance, alphabetically or by creation date).
</t>
<t>
  If an ORDERPATCH request does not change the ordering semantics, any 
  member positions not specified in the request MUST remain unchanged.
</t>
<t>
  A request to reposition a collection member to
  the same place in the 
  ordering is not an error. 
</t>
<t>
  If an ORDERPATCH request fails, the server state preceding the request MUST be restored. 
</t>
<t>
  Additional Marshalling:
  <list>
<t>
The request body MUST be DAV:orderpatch element.
</t>
<t>
<figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT orderpatch (ordering-type?, order-member*) >

   <!ELEMENT order-member (segment, position) >
   <!ELEMENT position (first | last | before | after)>
   <!ELEMENT segment (#PCDATA)>
   <!ELEMENT first EMPTY >
   <!ELEMENT last EMPTY >
   <!ELEMENT before segment >
   <!ELEMENT after segment >
]]></artwork></figure>
</t>
<t>
  PCDATA value: segment, as defined in section 3.3 of <xref target="RFC2396"/>.
</t>
<t>
  The DAV:ordering-type property is modified according to the DAV:ordering-type
  element.
</t>
<t>
  The ordering of internal member URIs in the collection identified by the
  Request-URI is changed based on instructions in the order-member
  XML elements. Specifically, in
  in the order that
  they appear in the request. The order-member XML 
  elements identify the internal member URIs whose positions are to be 
  changed, and describe their new positions in the ordering.
  Each new position can be specified as first in the ordering, last in the 
  ordering, immediately before some other internal member URI, or 
  immediately after some other internal member URI.  
</t>
<t>
  If a response body for a successful request is included, it MUST   be a DAV:orderpatch-response XML element.  Note that this
  document does not define any elements for the ORDERPATCH
  response body, but the DAV:orderpatch-response element is
  defined to ensure interoperability between future extensions that
  do define elements for the ORDERPATCH response body.
<figure><artwork type="application/xml-dtd"><![CDATA[
   <!ELEMENT orderpatch-response ANY>
]]></artwork></figure>
</t>
<t>
  Since multiple changes can be requested in a single ORDERPATCH request, 
  
  the server MUST return a 207 (Multi-Status)
  response (defined in <xref target="RFC2518"/>), containing DAV:response
  elements for either the request-URI (when the DAV:ordering-type could not
  be modified) or URIs of collection members to be repositioned (when an
  individual positioning request expressed as DAV:order-member could not be
  fulfilled) if any problems are encountered.
</t>
  </list>
</t>
<t>
  Preconditions:
  <list>
    <t>(DAV:collection-must-be-ordered): see <xref target="SECTION.SETTING.OVERVIEW"/>.</t>
    <t>(DAV:segment-must-identify-member): see <xref target="SECTION.SETTING.OVERVIEW"/>.</t>
  </list>
</t>
<t>
  Postconditions:
  <list>
    <t>
      <iref item="DAV:ordering-type-set postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:ordering-type-set (post)" primary="true"/>
    (DAV:ordering-type-set):
    if the request body contained a DAV:ordering-type element, the 
    request MUST have set the DAV:ordering-type property of the collection
    to the value specified in the request. </t>
    <t>
      <iref item="DAV:ordering-modified postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:ordering-modified (post)" primary="true"/>
    (DAV:ordering-modified):
    if the request body contained DAV:order-member elements, the request
    MUST have set the ordering of internal member URIs in the collection
    identified by the request-URI based upon
    instructions in the
    DAV:order-member elements.</t>
  </list>
</t>




<section title="Example: Changing a Collection Ordering">

<t>
  Consider an ordered collection /coll-1, with bindings ordered as follows:
</t>
<figure>
<artwork type="example"><![CDATA[
three.html
four.html
one.html
two.html
]]></artwork>
</figure>

<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
ORDERPATCH /coll-1/ HTTP/1.1
Host: example.org
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<?xml version="1.0" ?>
<d:orderpatch xmlns:d="DAV:">
   <d:ordering-type>
      <d:href>http://example.org/inorder.ord</d:href>
   </d:ordering-type>
   <d:order-member>
      <d:segment>two.html</d:segment>
      <d:position><d:first/></d:position>
   </d:order-member>
   <d:order-member>
      <d:segment>one.html</d:segment>
      <d:position><d:first/></d:position>
   </d:order-member>
   <d:order-member>
      <d:segment>three.html</d:segment>
      <d:position><d:last/></d:position>
   </d:order-member>
   <d:order-member>
      <d:segment>four.html</d:segment>
      <d:position><d:last/></d:position>
   </d:order-member>
</d:orderpatch>
]]></artwork></figure>

<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 200 OK
]]></artwork>
</figure>
<t>
  In this example, after the request has been processed, the collection's
  ordering semantics are identified by the URI http://example.org/inorder.ord.
  The value of the collection's DAV:ordering-type property has been set to this
  URI. The request also contains instructions for changing the positions of the
  collection's internal member URIs in the ordering to comply with the new
  ordering semantics.  As the
  DAV:order-member elements are required to be processed in 
  the order they appear in the request, two.html is moved 
  to the beginning of the ordering, and then one.html is moved to the 
  beginning of the ordering.  Then three.html is moved to the end of the 
  ordering, and finally four.html is moved to the end of the ordering. 
  After the request has been processed, the collection's ordering is as 
  follows:
</t>
<figure>
<artwork type="example"><![CDATA[
one.html
two.html
three.html
four.html
]]></artwork>
</figure>
</section>

<section title="Example: Failure of an ORDERPATCH Request">
<t>
  Consider a collection /coll-1/ with members ordered as follows:
</t>
<figure>
<artwork type="example"><![CDATA[
nunavut.map
nunavut.img
baffin.map
baffin.desc
baffin.img
iqaluit.map
nunavut.desc
iqaluit.img
iqaluit.desc
]]></artwork>
</figure>

<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
ORDERPATCH /coll-1/ HTTP/1.1
Host: www.nunanet.com
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<?xml version="1.0" ?>
<d:orderpatch xmlns:d="DAV:">
   <d:order-member>
      <d:segment>nunavut.desc</d:segment>
      <d:position> 
         <d:after>
            <d:segment>nunavut.map</d:segment>
         </d:after>
      </d:position>
   </d:order-member>
   <d:order-member>
      <d:segment>iqaluit.map</d:segment>
      <d:position>
         <d:after>
            <d:segment>pangnirtung.img</d:segment>
         </d:after>
      </d:position>
   </d:order-member>
</d:orderpatch>
]]></artwork>
</figure>

<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<?xml version="1.0" ?>
<d:multistatus xmlns:d="DAV:">
  <d:response>
    <d:href>http://www.nunanet.com/coll-1/iqaluit.map</d:href>
    <d:status>HTTP/1.1 403 Forbidden</d:status>
    <d:responsedescription>
      <d:error><d:segment-must-identify-member/></d:error>
      pangnirtung.img is not a collection member.
    </d:responsedescription>
  </d:response>
</d:multistatus>
]]></artwork>
</figure>
<t>
  In this example, the client attempted to position iqaluit.map after a 
  URI that is not an internal member of the collection /coll-1/.
  The server responded to this client error with a 403 (Forbidden) status code,
  indicating the failed precondition DAV:segment-must-identify-member. Because
  ORDERPATCH is an atomic method, the request to reposition 
  nunavut.desc (which would otherwise have succeeded) failed as well, but does not
  need to be expressed in the multistatus response body.
</t>
</section>
</section>

<section title="Listing the Members of an Ordered Collection" anchor="SECTION.LISTING">
<t>
  A PROPFIND request is used to retrieve a listing of the members of an 
  ordered collection, just as it is used to retrieve a listing of the 
  members of an unordered collection.  
</t>
<t>
  However, when responding to a PROPFIND on an ordered collection, the 
  server MUST order the response elements according to the ordering 
  defined on the collection. If a collection is unordered, the client 
  cannot depend on the repeatability of the ordering of results from a 
  PROPFIND request.
</t>
<t>
  In a response to a PROPFIND with Depth: infinity, members of different 
  collections may be interleaved.  That is, the server is not required to 
  do a breadth-first traversal.  The only requirement is that the members 
  of any ordered collection appear in the order defined for that 
  collection.  Thus,
  for the hierarchy illustrated in the following figure, 
  where collection A is an ordered collection with the ordering B C D,
</t>
<figure>
<artwork type="drawing"><![CDATA[
                    A
                   /|\
                  / | \
                 B  C  D
                /  /|\
               E  F G H
]]></artwork>
</figure>
<t>
  it would be acceptable for the server to return response elements in the 
  order A B E C F G H D 
  or "A B E C H G F D" as well (if C is unordered).
  In this response, B, C, and D appear in the 
  correct order, separated by members of other collections.  Clients can 
  use a series of Depth: 1 PROPFIND requests to avoid the complexity of 
  processing Depth: infinity responses based on depth-first traversals.
</t>

<section title="Example: PROPFIND on an Ordered Collection">
<t>
  Suppose a PROPFIND request is submitted to /MyColl/, which has its 
  members ordered as follows.
</t>
<figure>
<artwork type="example"><![CDATA[
/MyColl/
   lakehazen.html
   siorapaluk.html
   iqaluit.html
   newyork.html
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
PROPFIND /MyColl/ HTTP/1.1
Host: example.org
Depth: 1
Content-Type: text/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" ?>
<D:propfind xmlns:D="DAV:">
  <D:prop xmlns:J="http://example.org/jsprops/">
    <D:ordering-type/>
    <D:resourcetype/>
    <J:latitude/>
 </D:prop>
</D:propfind>
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" ?>
<D:multistatus xmlns:D="DAV:"
               xmlns:J="http://example.org/jsprops/">
   <D:response>
      <D:href>http://example.org/MyColl/</D:href>
      <D:propstat>
         <D:prop>
            <D:ordering-type>
               <D:href>DAV:custom</D:href>
            </D:ordering-type>
            <D:resourcetype><D:collection/></D:resourcetype>
         </D:prop>
         <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
      <D:propstat>
         <D:prop>
            <J:latitude/>
         </D:prop>
         <D:status>HTTP/1.1 404 Not Found</D:status>
      </D:propstat>
   </D:response>
   <D:response>
      <D:href>http://example.org/MyColl/lakehazen.html</D:href>
      <D:propstat>
         <D:prop>
            <D:resourcetype/>
            <J:latitude>82N</J:latitude>
         </D:prop>
         <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
      <D:propstat>
         <D:prop>
            <D:ordering-type/>
         </D:prop>
         <D:status>HTTP/1.1 404 Not Found</D:status>
      </D:propstat>
   </D:response>
   <D:response>
      <D:href
      >http://example.org/MyColl/siorapaluk.html</D:href>
      <D:propstat>
         <D:prop>
            <D:resourcetype/>
            <J:latitude>78N</J:latitude>
         </D:prop>
         <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
      <D:propstat>
         <D:prop>
            <D:ordering-type/>
         </D:prop>
         <D:status>HTTP/1.1 404 Not Found</D:status>
      </D:propstat>
   </D:response>
   <D:response>
      <D:href>http://example.org/MyColl/iqaluit.html</D:href>
      <D:propstat>
         <D:prop>
            <D:resourcetype/>
            <J:latitude>62N</J:latitude>
         </D:prop>
         <D:status>HTTP/1.1 200 OK</D:status>
      </D:propstat>
      <D:propstat>
         <D:prop>
            <D:ordering-type/>
         </D:prop>
         <D:status>HTTP/1.1 404 Not Found</D:status>
      </D:propstat>
   </D:response>
   <D:response>
      <D:href>http://example.org/MyColl/newyork.html</D:href>
      <D:propstat>
         <D:prop>
            <D:resourcetype/>
            <J:latitude>45N</J:latitude>
         </D:prop>
         <D:status>HTTP/1.1 200 OK</D:status>
      <D:propstat>
         <D:prop>
            <D:ordering-type/>
         </D:prop>
         <D:status>HTTP/1.1 404 Not Found</D:status>
      </D:propstat>
      </D:propstat>
   </D:response>
</D:multistatus>
]]></artwork>
</figure>
<t>
  In this example, the server responded with a list of the collection 
  members in the order defined for the collection.  
</t>
</section>
</section>


<section title="Relationship to versioned collections" anchor="SECTION.VERSIONING">
<t>
  The Versioning Extensions to WebDAV <xref target="RFC3253"/> introduce the 
  concept of versioned collections, recording both the dead properties and
  the set of internal version-controlled bindings. This section defines how
  this feature interacts with ordered collections.
</t>
<t>
  This specification considers both the ordering type (DAV:ordering-type property)
  and the ordering of collection members to be part of the state of a collection.
  Therefore,
  both MUST be recorded upon CHECKIN or VERSION-CONTROL, and both MUST be
  restored upon CHECKOUT, UNCHECKOUT or UPDATE (where for compatibility with
  RFC 3253, only the ordering of version-controlled members needs to be maintained).
</t>

<section title="Collection Version Properties">
<section title="Additional semantics for DAV:version-controlled-binding-set (protected)">
<t>
  For ordered collections, the DAV:version-controlled-binding elements MUST appear
  in the ordering defined for the checked-in ordered collection.
</t>
</section>
<section title="DAV:ordering-type (protected)">
<t>
  The DAV:ordering-type property records the DAV:ordering-type property of
  the checked-in ordered collection.
</t>
</section>
</section>
<section title="Additional CHECKIN semantics">
<t>
  Additional Postconditions:
  <list>
    <t>
      <iref item="DAV:initialize-version-controlled-bindings-ordered postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:initialize-version-controlled-bindings-ordered (post)" primary="true"/>
      (DAV:initialize-version-controlled-bindings-ordered): If the request-URL
      identified a both ordered and version-controlled collection, then the child
      elements of DAV:version-controlled-binding-set of the new collection version
      MUST appear in the ordering defined for that collection.
    </t>
    <t>
      <iref item="DAV:initialize-collection-version-ordering-type postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:initialize-collection-version-ordering-type (post)" primary="true"/>
      (DAV:initialize-collection-version-ordering-type): If the request-URL
      identified a both ordered and version-controlled collection, then the
      DAV:ordering-type property of the new collection version MUST be a copy
      of the collection's DAV:ordering-type property.
    </t>
  </list>
</t>
</section>
<section title="Additional CHECKOUT Semantics">
<t>
  Additional Postconditions:
  <list>
    <t>
      <iref item="DAV:initialize-version-history-bindings-ordered postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:initialize-version-history-bindings-ordered (post)" primary="true"/>
      (DAV:initialize-version-history-bindings-ordered): If the request has been
      applied to a collection version with a DAV:ordering-type other than "DAV:unordered",
      the bindings in the new working collection MUST be ordered according to the collection version's
      DAV:version-controlled-binding-set property.
    </t>
    <t>
      <iref item="DAV:initialize-ordering-type postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:initialize-ordering-type (post)" primary="true"/>
      (DAV:initialize-ordering-type): If the request has been
      applied to a collection version, the DAV:ordering-type property of
      the new working collection MUST be initialized from the collection
      version's DAV:ordering-type property.
    </t>
  </list>
</t>
</section>
<section title="Additional UNCHECKOUT, UPDATE, and MERGE Semantics">

<t>
  Additional Postconditions:
  <list>
    <t>
      <iref item="DAV:update-version-controlled-collection-members-ordered postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:update-version-controlled-collection-members-ordered (post)" primary="true"/>
      (DAV:update-version-controlled-collection-members-ordered): If the request 
      modified the DAV:checked-in version of a version-controlled collection
      and the DAV:ordering-type for the checked-in version is not unordered ("DAV:unordered"),
      the version-controlled members MUST be ordered according to the checked-in
      version's DAV:version-controlled-binding-set property. The ordering of
      non-version-controlled members is server-defined.
    </t>
    <t>
      <iref item="DAV:update-version-ordering-type postcondition" primary="true"/>
      <iref item="Condition Names" subitem="DAV:update-version-ordering-type (post)" primary="true"/>
      (DAV:update-version-ordering-type): If the request modified the
      DAV:checked-in version of a version-controlled collection, the 
      DAV:ordering-type property MUST be updated from the checked-in version's
      property.
    </t>
  </list>
</t>
</section>
</section>

<section title="Capability Discovery" anchor="SECTION.DISCOVERY">
<iref item="DAV header" subitem="compliance class 'ordered-collections'" primary="true"/>
<t>
  Sections 9.1 and 15 of <xref target="RFC2518"/> describe the use of compliance classes 
  with the DAV header in responses to OPTIONS, indicating
  which parts of 
  the Web Distributed Authoring protocols the resource supports. This 
  specification defines an OPTIONAL extension to <xref target="RFC2518"/>.  It defines a 
  new compliance class, called ordered-collections, for use with the DAV header in 
  responses to OPTIONS requests.  If a collection resource does support 
  ordering, its response to an OPTIONS request may indicate that it does, 
  by listing the new ORDERPATCH method as one it supports, and by listing 
  the new ordered-collections compliance class in the DAV header.
</t>
<t>
  When responding to an OPTIONS request, only a collection or a null 
  resource can include ordered-collections in the value of the DAV header.  By 
  including ordered-collections, the resource indicates that its internal member 
  URIs can be ordered.  It implies nothing about whether any collections 
  identified by its internal member URIs can be ordered.
</t>
<t>
  Furthermore, RFC 3253 <xref target="RFC3253"/> introduces the live properties
  DAV:supported-method-set (section 3.1.3) and DAV:supported-live-property-set
  (section 3.1.4). Servers MUST support these properties as defined in RFC 3253.
</t>


<section title="Example: Using OPTIONS for the Discovery of Support for Ordering">

<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[
OPTIONS /somecollection/ HTTP/1.1
Host: example.org
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[
HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE
Allow: MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, ORDERPATCH
DAV: 1, 2, ordered-collections
]]></artwork></figure>
<t>
  The DAV header in the response indicates that the resource 
  /somecollection/ is level 1 and level 2 compliant, as defined in 
  <xref target="RFC2518"/>.  In addition, /somecollection/ supports ordering.  The Allow 
  header indicates that ORDERPATCH requests can be submitted to 
  /somecollection/.
</t>
</section>


<section title="Example: Using Live Properties for the Discovery of Ordering">
<figure><preamble>
&gt;&gt; Request:</preamble>
<artwork type="message/http; msgtype=&#34;request&#34;"><![CDATA[PROPFIND /somecollection HTTP/1.1
Depth: 0
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<?xml version="1.0" encoding="UTF-8" ?>
<propfind xmlns="DAV:">
  <prop>
    <supported-live-property-set/>
    <supported-method-set/>
  </prop>
</propfind>
]]></artwork></figure>
<figure><preamble>
&gt;&gt; Response:</preamble>
<artwork type="message/http; msgtype=&#34;respone&#34;"><![CDATA[HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

<?xml version="1.0" encoding="utf-8" ?>
<multistatus xmlns="DAV:">
  <response>
    <href>http://example.org/somecollection</href>
    <propstat>
      <prop>
        <supported-live-property-set>
          <supported-live-property>
            <prop><ordering-type/></prop>
          </supported-live-property>
          <!-- ... other live properties omitted for brevity ... -->
        </supported-live-property-set>
        <supported-method-set>
          <supported-method name="COPY" />
          <supported-method name="DELETE" />
          <supported-method name="GET" />
          <supported-method name="HEAD" />
          <supported-method name="LOCK" />
          <supported-method name="MKCOL" />
          <supported-method name="MOVE" />
          <supported-method name="OPTIONS" />
          <supported-method name="ORDERPATCH" />
          <supported-method name="POST" />
          <supported-method name="PROPFIND" />
          <supported-method name="PROPPATCH" />
          <supported-method name="PUT" />
          <supported-method name="TRACE" />
          <supported-method name="UNLOCK" />
        </supported-method-set>
      </prop>
      <status>HTTP/1.1 200 OK</status>
    </propstat>
  </response>
</multistatus>
]]></artwork></figure>
<t>
  Note that actual responses MUST contain a complete list of supported live
  properties.
</t>
</section>
</section>

<section title="Security Considerations" anchor="SECTION.SECURITY">

<t>
  This section is provided to make WebDAV implementers aware of the 
  security implications of this protocol. 
</t>
<t>
  All of the security considerations of HTTP/1.1 and the WebDAV 
  Distributed Authoring Protocol specification also apply to this protocol 
  specification.  In addition, ordered collections introduce a new 
  security concern.  This issue is detailed here.
</t>

<section title="Denial of Service and DAV:ordering-type">
<t>
  There may be some risk of denial of service at sites that are advertised 
  in the DAV:ordering-type property of collections.  However, it is 
  anticipated that widely-deployed applications will use hard-coded values 
  for frequently-used ordering semantics rather than looking up the 
  semantics at the location specified by DAV:ordering-type.  This risk will 
  be further reduced if clients observe the recommendation of <xref target="SECTION.CREATING.OVERVIEW"/> that
  requests not be sent
  to the URI in DAV:ordering-type.
</t>
</section>
</section>

<section title="Internationalization Considerations">
<t>
  This specification follows the practices of <xref target="RFC2518"/> by encoding all 
  human-readable content using <xref target="XML"/> and in the treatment of names.  
  Consequently, this specification complies with the IETF Character Set 
  Policy <xref target="RFC2277"/>.
</t>
<t>
  WebDAV applications MUST support the character set tagging, character 
  set encoding, and the language tagging functionality of the XML 
  specification.  This constraint ensures that the human-readable content 
  of this specification complies with <xref target="RFC2277"/>.
</t>
<t>
  As in <xref target="RFC2518"/>, names in this specification fall into three categories: 
  names of protocol elements such as methods and headers, names of XML 
  elements, and names of properties. The naming
  of protocol elements follows 
  the precedent of HTTP
  using English names encoded in USASCII for 
  methods and headers.  The names of XML elements used in this 
  specification are English names encoded in UTF-8.
</t>
<t>
  For error reporting, <xref target="RFC2518"/> follows the convention of HTTP/1.1 status 
  codes, including with each status code a short, English description of 
  the code (e.g., 423 Locked).  Internationalized applications will ignore 
  this message, and display an appropriate message in the user's language 
  and character set.
</t>
<t>
  This specification introduces no new strings that are displayed to users 
  as part of normal, error-free operation of the protocol.
</t>
<t>
  For the rationale of these decisions and advice for application 
  implementers, see <xref target="RFC2518"/>.
</t>
</section>

<section title="IANA Considerations" anchor="SECTION.IANA">
<t>
  This document uses the namespaces defined by <xref target="RFC2518"/> for properties and 
  XML elements.  All other IANA considerations mentioned in <xref target="RFC2518"/> also 
  apply to this document.
</t>
</section>

<section title="Contributors">
<t>
  This document has benefited from significant contributions from
  Geoff Clemm, Jason Crawford, Jim Davis, Chuck Fay and Judith Slein.
</t>
</section>

<section title="Acknowledgements">
<t>
  This document has benefited from thoughtful discussion by Jim Amsden, Steve
  Carter, Tyson Chihaya, Ken Coar, Ellis Cohen, Bruce Cragun,
  Spencer Dawkins, Mark Day, Rajiv Dulepet, David Durand,
  Lisa Dusseault, Roy Fielding, Yaron Goland, Fred
  Hitt, Alex Hopmann, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit
  Khare, Daniel LaLiberte, Steve Martin, Larry
  Masinter, Jeff McAffer, Surendra Koduru Reddy, Max Rible, Sam Ruby, Bradley
  Sergeant, Nick Shelness, John Stracke, John Tigue, John Turner, Kevin Wiggen,
  and others.
</t>
</section>

    </middle>
	<back>

<references title="Normative References">
	
<reference anchor="RFC2277">

<front>
<title abbrev="Charset Policy">IETF Policy on Character Sets and Languages</title>
<author initials="H.T." surname="Alvestrand" fullname="Harald Tveit Alvestrand">
<organization>UNINETT</organization>
<address>
<postal>
<street>P.O.Box 6883 Elgeseter</street>
<street>N-7002 TRONDHEIM</street>
<country>NORWAY</country></postal>
<phone>+47 73 59 70 94</phone>
<email>Harald.T.Alvestrand@uninett.no</email></address></author>
<date month="January" year="1998"/>
<area>Applications</area>
<keyword>Internet Engineering Task Force</keyword>
<keyword>character encoding</keyword></front>

<seriesInfo name="BCP" value="18"/>
<seriesInfo name="RFC" value="2277"/>
</reference>

<reference anchor="RFC2396">

<front>
<title abbrev="URI Generic Syntax">Uniform Resource Identifiers (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="Tim Berners-Lee">
<organization>World Wide Web Consortium</organization>
<address>
<postal>
<street>MIT Laboratory for Computer Science, NE43-356</street>
<street>545 Technology Square</street>
<city>Cambridge</city>
<region>MA</region>
<code>02139</code></postal>
<facsimile>+1(617)258-8682</facsimile>
<email>timbl@w3.org</email></address></author>
<author initials="R.T." surname="Fielding" fullname="Roy T. Fielding">
<organization>Department of Information and Computer Science</organization>
<address>
<postal>
<street>University of California, Irvine</street>
<city>Irvine</city>
<region>CA</region>
<code>92697-3425</code></postal>
<facsimile>+1(949)824-1715</facsimile>
<email>fielding@ics.uci.edu</email></address></author>
<author initials="L." surname="Masinter" fullname="Larry Masinter">
<organization>Xerox PARC</organization>
<address>
<postal>
<street>3333 Coyote Hill Road</street>
<city>Palo Alto</city>
<region>CA</region>
<code>94034</code></postal>
<facsimile>+1(415)812-4333</facsimile>
<email>masinter@parc.xerox.com</email></address></author>
<date month="August" year="1998"/>
<area>Applications</area>
<keyword>uniform resource</keyword>
<keyword>URI</keyword>
<abstract>
<t>
   A Uniform Resource Identifier (URI) is a compact string of characters
   for identifying an abstract or physical resource.  This document
   defines the generic syntax of URI, including both absolute and
   relative forms, and guidelines for their use; it revises and replaces
   the generic definitions in RFC 1738 and RFC 1808.
</t>
<t>
   This document defines a grammar that is a superset of all valid URI,
   such that an implementation can parse the common components of a URI
   reference without knowing the scheme-specific requirements of every
   possible identifier type.  This document does not define a generative
   grammar for URI; that task will be performed by the individual
   specifications of each URI scheme.
</t></abstract>
<note title="IESG Note">
<t>
   This paper describes a "superset" of operations that can be applied
   to URI.  It consists of both a grammar and a description of basic
   functionality for URI.  To understand what is a valid URI, both the
   grammar and the associated description have to be studied.  Some of
   the functionality described is not applicable to all URI schemes, and
   some operations are only possible when certain media types are
   retrieved using the URI, regardless of the scheme used.
</t></note></front>

<seriesInfo name="RFC" value="2396"/>
</reference>

<reference anchor="RFC2119">

<front>
<title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials="S." surname="Bradner" fullname="Scott Bradner">
<organization>Harvard University</organization>
<address>
<postal>
<street>1350 Mass. Ave.</street>
<street>Cambridge</street>
<street>MA 02138</street></postal>
<phone>- +1 617 495 3864</phone>
</address></author>
<date month="March" year="1997"/>
<area>General</area>
<keyword>keyword</keyword>
</front>

<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
</reference>

<reference anchor="XML" target="http://www.w3.org/TR/2000/REC-xml-20001006">
  <front>
    <title>Extensible Markup Language (XML) 1.0 (2nd ed)</title>
    <author initials="T." surname="Bray" fullname="Tim Bray">
      <organization>Textuality and Netscape</organization>
      <address>
        <email>tbray@textuality.com</email>
      </address>
    </author>
    <author initials="J." surname="Paoli" fullname="Jean Paoli">
      <organization>Microsoft</organization>
      <address>
        <email>jeanpa@microsoft.com</email>
      </address>
    </author>
    <author initials="C.M." surname="Sperberg-McQueen" fullname="C. M. Sperberg-McQueen">
      <organization>University of Illinois at Chicago and Text Encoding Initiative</organization>
      <address>
        <email>cmsmcq@uic.edu</email>
      </address>
    </author>
    <author initials="E." surname="Maler" fullname="Eve Maler">
      <organization>Sun Microsystems</organization>
      <address>
        <email>eve.maler@east.sun.com</email>
      </address>
    </author>
    <date day="6" month="October" year="2000"/>
  </front>
  <seriesInfo name="W3C" value="REC-xml"/>
</reference>

<reference anchor="RFC2616">

<front>
<title>Hypertext Transfer Protocol -- HTTP/1.1</title>
<author initials="R." surname="Fielding" fullname="R. Fielding">
  <organization>University of California, Irvine</organization>
  <address><email>fielding@ics.uci.edu</email></address>
</author>
<author initials="J." surname="Gettys" fullname="J. Gettys">
  <organization>W3C</organization>
  <address><email>jg@w3.org</email></address>
</author>
<author initials="J." surname="Mogul" fullname="J. Mogul">
  <organization>Compaq Computer Corporation</organization>
  <address><email>mogul@wrl.dec.com</email></address>
</author>
<author initials="H." surname="Frystyk" fullname="H. Frystyk">
  <organization>MIT Laboratory for Computer Science</organization>
  <address><email>frystyk@w3.org</email></address>
</author>
<author initials="L." surname="Masinter" fullname="L. Masinter">
  <organization>Xerox Corporation</organization>
  <address><email>masinter@parc.xerox.com</email></address>
</author>
<author initials="P." surname="Leach" fullname="P. Leach">
  <organization>Microsoft Corporation</organization>
  <address><email>paulle@microsoft.com</email></address>
</author>
<author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee">
  <organization>W3C</organization>
  <address><email>timbl@w3.org</email></address>
</author>
<date month="June" year="1999"/></front>

<seriesInfo name="RFC" value="2616"/>
</reference>

<reference anchor="RFC2518">

<front>
<title>HTTP Extensions for Distributed Authoring -- WEBDAV</title>
<author initials="Y." surname="Goland" fullname="Y. Goland">
  <organization>Microsoft Corporation</organization>
  <address><email>yarong@microsoft.com</email></address>
</author>
<author initials="E." surname="Whitehead" fullname="E. J. Whitehead, Jr.">
  <organization abbrev="UC Irvine">Dept. Of Information and Computer Science, University of California, Irvine</organization>
	<address><email>ejw@ics.uci.edu</email></address>
</author>
<author initials="A." surname="Faizi" fullname="A. Faizi">
  <organization abbrev="Netscape">Netscape</organization>
  <address><email>asad@netscape.com</email></address>
</author>
<author initials="S.R." surname="Carter" fullname="S. R. Carter">
  <organization abbrev="Novell">Novell</organization>
  <address><email>srcarter@novell.com</email></address>
</author>
<author initials="D." surname="Jensen" fullname="D. Jensen">
  <organization abbrev="Novell">Novell</organization>
  <address><email>dcjensen@novell.com</email></address>
</author>
<date month="February" year="1999"/></front>

<seriesInfo name="RFC" value="2518"/>
</reference>

<reference anchor="RFC3253">

<front>
<title>Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</title>
<author initials="G." surname="Clemm" fullname="G. Clemm">
  <organization>Rational Software</organization>
  <address><email>geoffrey.clemm@rational.com</email></address>
</author>
<author initials="J." surname="Amsden" fullname="J. Amsden">
  <organization>IBM</organization>
  <address><email>jamsden@us.ibm.com</email></address>
</author>
<author initials="T." surname="Ellison" fullname="T. Ellison">
  <organization>IBM</organization>
  <address><email>tim_ellison@uk.ibm.com</email></address>
</author>
<author initials="C." surname="Kaler" fullname="C. Kaler">
  <organization>Microsoft</organization>
  <address><email>ckaler@microsoft.com</email></address>
</author>
<author initials="J." surname="Whitehead" fullname="J. Whitehead">
  <organization>UC Santa Cruz, Dept. of Computer Science</organization>
  <address><email>ejw@cse.ucsc.edu</email></address>
</author>
<date month="March" year="2002"/></front>

<seriesInfo name="RFC" value="3253"/>
</reference>

</references>

<section title="Extensions to the WebDAV Document Type Definition">

<figure><artwork type="application/xml-dtd"><![CDATA[
<!ELEMENT orderpatch (ordering-type?, order-member*) >
<!ELEMENT order-member (segment, position) >
<!ELEMENT ordering-type (href) >
<!ELEMENT position (first | last | before | after)>
<!ELEMENT first EMPTY >
<!ELEMENT last EMPTY >
<!ELEMENT before segment >
<!ELEMENT after segment >
<!ELEMENT segment (#PCDATA)>
]]></artwork></figure>

</section>

    </back>

</rfc>